/**
 * UBI Design System - Style Dictionary Configuration
 *
 * This configuration transforms our design tokens into multiple output formats:
 * - CSS Custom Properties
 * - TypeScript constants
 * - Tailwind CSS theme config
 * - Dart constants (for Flutter)
 */

import StyleDictionary from "style-dictionary";
import { fileHeader, formattedVariables } from "style-dictionary/utils";

// =============================================================================
// CUSTOM TRANSFORMS
// =============================================================================

/**
 * Transform token names to CSS variable format
 * e.g., "color.brand.primary" -> "--ubi-color-brand-primary"
 */
StyleDictionary.registerTransform({
  name: "name/ubi/kebab",
  type: "name",
  transform: (token) => {
    return `ubi-${token.path.join("-")}`;
  },
});

/**
 * Transform shadow values to CSS format
 */
StyleDictionary.registerTransform({
  name: "shadow/css",
  type: "value",
  filter: (token) => token.$type === "shadow" || token.type === "shadow",
  transform: (token) => {
    return token.$value || token.value;
  },
});

/**
 * Transform duration values to ms format
 */
StyleDictionary.registerTransform({
  name: "time/ms",
  type: "value",
  filter: (token) => token.$type === "duration" || token.type === "duration",
  transform: (token) => {
    const value = token.$value || token.value;
    if (typeof value === "string" && value.endsWith("ms")) {
      return value;
    }
    return `${value}ms`;
  },
});

/**
 * Transform cubic-bezier values
 */
StyleDictionary.registerTransform({
  name: "cubicBezier/css",
  type: "value",
  filter: (token) =>
    token.$type === "cubicBezier" || token.type === "cubicBezier",
  transform: (token) => {
    return token.$value || token.value;
  },
});

// =============================================================================
// CUSTOM FORMATS
// =============================================================================

/**
 * CSS Custom Properties format with support for light/dark themes
 */
StyleDictionary.registerFormat({
  name: "css/ubi-variables",
  format: async ({ dictionary, file, options }) => {
    const { outputReferences } = options;
    const header = await fileHeader({ file });

    return (
      header +
      ":root {\n" +
      formattedVariables({ format: "css", dictionary, outputReferences }) +
      "\n}\n"
    );
  },
});

/**
 * CSS Custom Properties format for dark mode
 */
StyleDictionary.registerFormat({
  name: "css/ubi-dark-variables",
  format: async ({ dictionary, file, options }) => {
    const { outputReferences } = options;
    const header = await fileHeader({ file });

    return (
      header +
      ':root.dark,\n[data-theme="dark"],\n.dark {\n' +
      formattedVariables({ format: "css", dictionary, outputReferences }) +
      "\n}\n\n" +
      "@media (prefers-color-scheme: dark) {\n" +
      '  :root:not(.light):not([data-theme="light"]) {\n' +
      formattedVariables({
        format: "css",
        dictionary,
        outputReferences,
        indentation: "    ",
      }) +
      "\n  }\n}\n"
    );
  },
});

/**
 * TypeScript constants format
 */
StyleDictionary.registerFormat({
  name: "typescript/ubi-constants",
  format: async ({ dictionary, file }) => {
    const header = await fileHeader({ file, commentStyle: "short" });

    const tokens = {};

    dictionary.allTokens.forEach((token) => {
      let current = tokens;
      token.path.forEach((key, index) => {
        if (index === token.path.length - 1) {
          current[key] = token.$value || token.value;
        } else {
          current[key] = current[key] || {};
          current = current[key];
        }
      });
    });

    return (
      header +
      "// Auto-generated by Style Dictionary\n" +
      "// Do not edit directly\n\n" +
      "export const tokens = " +
      JSON.stringify(tokens, null, 2) +
      " as const;\n\n" +
      "export type TokenKeys = keyof typeof tokens;\n"
    );
  },
});

/**
 * Tailwind CSS theme format
 */
StyleDictionary.registerFormat({
  name: "tailwind/ubi-theme",
  format: async ({ dictionary, file }) => {
    const header = await fileHeader({ file, commentStyle: "short" });

    const colors = {};
    const spacing = {};
    const fontSize = {};
    const fontFamily = {};
    const fontWeight = {};
    const lineHeight = {};
    const letterSpacing = {};
    const borderRadius = {};
    const boxShadow = {};
    const transitionDuration = {};
    const transitionTimingFunction = {};
    const zIndex = {};

    dictionary.allTokens.forEach((token) => {
      const value = `var(--${token.name})`;
      const path = token.path;

      if (path[0] === "color") {
        let target = colors;
        for (let i = 1; i < path.length - 1; i++) {
          target[path[i]] = target[path[i]] || {};
          target = target[path[i]];
        }
        target[path[path.length - 1]] = value;
      }

      if (path[0] === "spacing") {
        spacing[path[1]] = value;
      }

      if (path[0] === "font") {
        if (path[1] === "size") {
          fontSize[path[2]] = value;
        }
        if (path[1] === "family") {
          fontFamily[path[2]] = value;
        }
        if (path[1] === "weight") {
          fontWeight[path[2]] = value;
        }
        if (path[1] === "lineHeight") {
          lineHeight[path[2]] = value;
        }
        if (path[1] === "letterSpacing") {
          letterSpacing[path[2]] = value;
        }
      }

      if (path[0] === "radius") {
        borderRadius[path[1]] = value;
      }

      if (path[0] === "shadow") {
        boxShadow[path[1]] = value;
      }

      if (path[0] === "motion") {
        if (path[1] === "duration") {
          transitionDuration[path[2]] = value;
        }
        if (path[1] === "easing") {
          transitionTimingFunction[path[2]] = value;
        }
      }

      if (path[0] === "zIndex") {
        zIndex[path[1]] = value;
      }
    });

    const theme = {
      colors,
      spacing,
      fontSize,
      fontFamily,
      fontWeight,
      lineHeight,
      letterSpacing,
      borderRadius,
      boxShadow,
      transitionDuration,
      transitionTimingFunction,
      zIndex,
    };

    return (
      header +
      "// Auto-generated by Style Dictionary\n" +
      "// Do not edit directly\n\n" +
      'import type { Config } from "tailwindcss";\n\n' +
      'export const ubiTheme: Partial<Config["theme"]> = ' +
      JSON.stringify(theme, null, 2) +
      ";\n\n" +
      "export default ubiTheme;\n"
    );
  },
});

/**
 * Dart constants format for Flutter
 */
StyleDictionary.registerFormat({
  name: "dart/ubi-constants",
  format: async ({ dictionary, file }) => {
    const header =
      "// Auto-generated by Style Dictionary\n// Do not edit directly\n\n";

    let output = header;
    output += "import 'package:flutter/material.dart';\n\n";
    output += "/// UBI Design System Tokens\n";
    output += "abstract class UbiTokens {\n";
    output += "  UbiTokens._();\n\n";

    // Group tokens by category
    const categories = {};
    dictionary.allTokens.forEach((token) => {
      const category = token.path[0];
      if (!categories[category]) {
        categories[category] = [];
      }
      categories[category].push(token);
    });

    Object.entries(categories).forEach(([category, tokens]) => {
      output += `  // ${category.charAt(0).toUpperCase() + category.slice(1)}\n`;

      tokens.forEach((token) => {
        const name = token.path.join("").replace(/[.-]/g, "");
        const camelName = name.replace(/([A-Z])/g, "_$1").toLowerCase();
        const value = token.$value || token.value;

        if (token.$type === "color" || token.type === "color") {
          // Convert hex to Flutter Color
          if (typeof value === "string" && value.startsWith("#")) {
            const hex = value.replace("#", "");
            const alpha = hex.length === 8 ? hex.substring(6, 8) : "FF";
            const rgb = hex.length === 8 ? hex.substring(0, 6) : hex;
            output += `  static const Color ${camelName} = Color(0x${alpha.toUpperCase()}${rgb.toUpperCase()});\n`;
          }
        } else if (token.$type === "dimension" || token.type === "dimension") {
          // Convert to double
          const numValue = parseFloat(value);
          output += `  static const double ${camelName} = ${numValue};\n`;
        } else if (
          token.$type === "fontWeight" ||
          token.type === "fontWeight"
        ) {
          output += `  static const FontWeight ${camelName} = FontWeight.w${value};\n`;
        } else if (token.$type === "number" || token.type === "number") {
          output += `  static const double ${camelName} = ${value};\n`;
        }
      });

      output += "\n";
    });

    output += "}\n";

    return output;
  },
});

// =============================================================================
// CONFIGURATION
// =============================================================================

const config = {
  source: ["tokens/**/*.json"],

  platforms: {
    // CSS Custom Properties (Light mode)
    css: {
      transformGroup: "css",
      transforms: [
        "name/ubi/kebab",
        "shadow/css",
        "time/ms",
        "cubicBezier/css",
      ],
      buildPath: "dist/css/",
      files: [
        {
          destination: "tokens.css",
          format: "css/ubi-variables",
          filter: (token) => {
            // Exclude dark mode tokens
            return !token.filePath.includes("dark.json");
          },
          options: {
            outputReferences: true,
          },
        },
        {
          destination: "tokens.dark.css",
          format: "css/ubi-dark-variables",
          filter: (token) => {
            // Only dark mode tokens
            return token.filePath.includes("dark.json");
          },
          options: {
            outputReferences: true,
          },
        },
      ],
    },

    // TypeScript constants
    ts: {
      transformGroup: "js",
      transforms: [
        "name/ubi/kebab",
        "shadow/css",
        "time/ms",
        "cubicBezier/css",
      ],
      buildPath: "dist/ts/",
      files: [
        {
          destination: "tokens.ts",
          format: "typescript/ubi-constants",
          filter: (token) => !token.filePath.includes("dark.json"),
        },
        {
          destination: "tokens.dark.ts",
          format: "typescript/ubi-constants",
          filter: (token) => token.filePath.includes("dark.json"),
        },
      ],
    },

    // Tailwind CSS theme
    tailwind: {
      transformGroup: "js",
      transforms: ["name/ubi/kebab"],
      buildPath: "dist/tailwind/",
      files: [
        {
          destination: "theme.ts",
          format: "tailwind/ubi-theme",
          filter: (token) => !token.filePath.includes("dark.json"),
        },
      ],
    },

    // Dart constants for Flutter
    dart: {
      transformGroup: "flutter",
      buildPath: "dist/dart/",
      files: [
        {
          destination: "tokens.dart",
          format: "dart/ubi-constants",
          filter: (token) =>
            !token.filePath.includes("dark.json") &&
            !token.filePath.includes("semantic.json"),
        },
      ],
    },

    // JSON output (for tooling integration)
    json: {
      transformGroup: "js",
      buildPath: "dist/json/",
      files: [
        {
          destination: "tokens.json",
          format: "json/nested",
          filter: (token) => !token.filePath.includes("dark.json"),
        },
        {
          destination: "tokens.dark.json",
          format: "json/nested",
          filter: (token) => token.filePath.includes("dark.json"),
        },
      ],
    },
  },
};

export default config;
